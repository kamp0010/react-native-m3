package com.maxrave.simpmusic.ui.component

import androidx.compose.animation.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ImageBitmap
import coil3.compose.AsyncImage
import coil3.compose.LocalPlatformContext
import coil3.request.CachePolicy
import coil3.request.ImageRequest
import coil3.request.crossfade
import coil3.toBitmap
import com.kmpalette.palette.graphics.Palette
import com.kmpalette.rememberPaletteState
import com.maxrave.simpmusic.ui.theme.md_theme_dark_background
import kotlinx.coroutines.flow.distinctUntilChanged

/**
 * ============================================================================
 * GRADIENT CLASSES & ENUMS
 * ============================================================================
 */

/**
 * Data class for gradient offset configuration
 * Defines the start and end points for linear gradient
 */
data class GradientOffset(
    val start: Offset,
    val end: Offset,
)

/**
 * Enum for 8 different gradient angles (in clockwise direction)
 */
enum class GradientAngle {
    CW0,
    CW45,
    CW90,
    CW135,
    CW180,
    CW225,
    CW270,
    CW315,
}

/**
 * ============================================================================
 * GRADIENT UTILITY FUNCTIONS
 * ============================================================================
 */

/**
 * Converts a GradientAngle to GradientOffset with proper start and end points
 * Each angle defines the direction of the gradient
 *
 * @param angle The gradient angle (CW0 to CW315)
 * @return GradientOffset with calculated start and end points
 */
fun GradientOffset(angle: GradientAngle): GradientOffset =
    when (angle) {
        GradientAngle.CW45 ->
            GradientOffset(
                start = Offset.Zero,
                end = Offset.Infinite,
            )

        GradientAngle.CW90 ->
            GradientOffset(
                start = Offset.Zero,
                end = Offset(0f, Float.POSITIVE_INFINITY),
            )

        GradientAngle.CW135 ->
            GradientOffset(
                start = Offset(Float.POSITIVE_INFINITY, 0f),
                end = Offset(0f, Float.POSITIVE_INFINITY),
            )

        GradientAngle.CW180 ->
            GradientOffset(
                start = Offset(Float.POSITIVE_INFINITY, 0f),
                end = Offset.Zero,
            )

        GradientAngle.CW225 ->
            GradientOffset(
                start = Offset.Infinite,
                end = Offset.Zero,
            )

        GradientAngle.CW270 ->
            GradientOffset(
                start = Offset(0f, Float.POSITIVE_INFINITY),
                end = Offset.Zero,
            )

        GradientAngle.CW315 ->
            GradientOffset(
                start = Offset(0f, Float.POSITIVE_INFINITY),
                end = Offset(Float.POSITIVE_INFINITY, 0f),
            )

        else ->
            GradientOffset(
                start = Offset.Zero,
                end = Offset(Float.POSITIVE_INFINITY, 0f),
            )
    }

/**
 * Extracts vibrant colors from an image palette using priority-based selection
 * Priority order: DarkVibrant > DarkMuted > Vibrant > Muted > LightVibrant > LightMuted
 *
 * @return Extracted Color or falls back to md_theme_dark_background if no palette
 */
fun Palette?.getColorFromPalette(): Color {
    val p = this ?: return md_theme_dark_background
    val defaultColor = 0x000000
    var startColor = p.getDarkVibrantColor(defaultColor)
    if (startColor == defaultColor) {
        startColor = p.getDarkMutedColor(defaultColor)
        if (startColor == defaultColor) {
            startColor = p.getVibrantColor(defaultColor)
            if (startColor == defaultColor) {
                startColor = p.getMutedColor(defaultColor)
                if (startColor == defaultColor) {
                    startColor = p.getLightVibrantColor(defaultColor)
                    if (startColor == defaultColor) {
                        startColor = p.getLightMutedColor(defaultColor)
                    }
                }
            }
        }
    }
    return Color(startColor)
}

/**
 * ============================================================================
 * MAIN COMPOSABLE COMPONENTS
 * ============================================================================
 */

/**
 * A reusable gradient background component that automatically extracts colors
 * from album artwork and applies a smooth animated gradient
 *
 * Usage:
 * ```
 * GradientBackgroundFromImage(
 *     imageUrl = "https://example.com/album.jpg",
 *     gradientAngle = GradientAngle.CW135,
 *     endColor = Color.Black,
 *     modifier = Modifier.fillMaxSize(),
 *     content = {
 *         // Your player content here
 *     }
 * )
 * ```
 *
 * @param imageUrl URL of the album artwork image
 * @param gradientAngle The angle direction of the gradient (default: CW135)
 * @param endColor The end color of the gradient (default: md_theme_dark_background)
 * @param animationDuration Duration of color animation in milliseconds (default: 300)
 * @param modifier Modifier for the Box
 * @param content Composable lambda for content to be displayed over gradient
 */
@Composable
fun GradientBackgroundFromImage(
    imageUrl: String,
    gradientAngle: GradientAngle = GradientAngle.CW135,
    endColor: Color = md_theme_dark_background,
    animationDuration: Int = 300,
    modifier: Modifier = Modifier.fillMaxSize(),
    content: @Composable () -> Unit = {},
) {
    // Palette state for color extraction from image
    val paletteState = rememberPaletteState()

    // Animated start color (extracted from palette)
    val startColor = remember { Animatable(md_theme_dark_background) }

    // Gradient offset based on selected angle
    val gradientOffset by remember { mutableStateOf(GradientOffset(gradientAngle)) }

    // Store bitmap of the album art
    var albumBitmap by remember { mutableStateOf<ImageBitmap?>(null) }

    // Generate palette from the loaded image
    LaunchedEffect(imageUrl) {
        // Load image and convert to bitmap for palette generation
        val request = ImageRequest
            .Builder(LocalPlatformContext.current)
            .data(imageUrl)
            .diskCachePolicy(CachePolicy.ENABLED)
            .crossfade(300)
            .build()
        
        try {
            val bitmap = request.context.imageLoader.executeBlocking(request).image?.let {
                // Convert drawable to bitmap
                it
            }
            // Note: In real implementation, you'd use Coil's toBitmap() extension
            // This requires the image to be loaded first
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    // Extract and animate colors from palette
    LaunchedEffect(Unit) {
        snapshotFlow { paletteState.palette }
            .distinctUntilChanged()
            .collect { palette ->
                val extractedColor = palette.getColorFromPalette()
                startColor.animateTo(
                    targetValue = extractedColor,
                    animationSpec = tween(durationMillis = animationDuration),
                )
            }
    }

    // Display the image (optional, can be hidden or used as background)
    AsyncImage(
        model = ImageRequest
            .Builder(LocalPlatformContext.current)
            .data(imageUrl)
            .diskCachePolicy(CachePolicy.ENABLED)
            .crossfade(300)
            .build(),
        contentDescription = "Album Artwork",
        modifier = Modifier.fillMaxSize(),
    ) { state ->
        // Generate palette from the successfully loaded image
        state.result.takeIf { it.image != null }?.let { result ->
            LaunchedEffect(result.image) {
                try {
                    paletteState.generate(result.image!!)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    // Apply gradient background
    Box(
        modifier = modifier.background(
            Brush.linearGradient(
                colors = listOf(
                    startColor.value,
                    endColor,
                ),
                start = gradientOffset.start,
                end = gradientOffset.end,
            ),
        ),
    ) {
        content()
    }
}

/**
 * Simplified version that takes a bitmap directly
 * Useful when you already have the image bitmap loaded
 *
 * Usage:
 * ```
 * GradientBackgroundFromBitmap(
 *     bitmap = imageBitmap,
 *     gradientAngle = GradientAngle.CW90,
 *     modifier = Modifier.fillMaxSize(),
 * ) {
 *     // Your content
 * }
 * ```
 *
 * @param bitmap The ImageBitmap to extract colors from
 * @param gradientAngle The angle direction of the gradient
 * @param endColor The end color of the gradient
 * @param animationDuration Duration of color animation in milliseconds
 * @param modifier Modifier for the Box
 * @param content Composable lambda for content to be displayed over gradient
 */
@Composable
fun GradientBackgroundFromBitmap(
    bitmap: ImageBitmap,
    gradientAngle: GradientAngle = GradientAngle.CW135,
    endColor: Color = md_theme_dark_background,
    animationDuration: Int = 300,
    modifier: Modifier = Modifier.fillMaxSize(),
    content: @Composable () -> Unit = {},
) {
    // Palette state for color extraction
    val paletteState = rememberPaletteState()

    // Animated start color
    val startColor = remember { Animatable(md_theme_dark_background) }

    // Gradient offset based on angle
    val gradientOffset by remember { mutableStateOf(GradientOffset(gradientAngle)) }

    // Generate palette from bitmap immediately
    LaunchedEffect(bitmap) {
        try {
            paletteState.generate(bitmap)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    // Extract and animate colors
    LaunchedEffect(Unit) {
        snapshotFlow { paletteState.palette }
            .distinctUntilChanged()
            .collect { palette ->
                val extractedColor = palette.getColorFromPalette()
                startColor.animateTo(
                    targetValue = extractedColor,
                    animationSpec = tween(durationMillis = animationDuration),
                )
            }
    }

    // Apply gradient
    Box(
        modifier = modifier.background(
            Brush.linearGradient(
                colors = listOf(
                    startColor.value,
                    endColor,
                ),
                start = gradientOffset.start,
                end = gradientOffset.end,
            ),
        ),
    ) {
        content()
    }
}

/**
 * A simple gradient background with pre-defined colors
 * No image-based color extraction, useful for static gradients
 *
 * @param startColor The start color of the gradient
 * @param endColor The end color of the gradient
 * @param gradientAngle The angle direction of the gradient
 * @param modifier Modifier for the Box
 * @param content Composable lambda for content
 */
@Composable
fun SimpleGradientBackground(
    startColor: Color,
    endColor: Color,
    gradientAngle: GradientAngle = GradientAngle.CW135,
    modifier: Modifier = Modifier.fillMaxSize(),
    content: @Composable () -> Unit = {},
) {
    val gradientOffset by remember { mutableStateOf(GradientOffset(gradientAngle)) }

    Box(
        modifier = modifier.background(
            Brush.linearGradient(
                colors = listOf(startColor, endColor),
                start = gradientOffset.start,
                end = gradientOffset.end,
            ),
        ),
    ) {
        content()
    }
}